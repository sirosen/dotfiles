#!/usr/bin/env _python_requirements_launcher
# Requirements:
#   libcst
import argparse
import glob
import os
import subprocess
import sys

import libcst
import libcst.matchers


def is_python(filename: str) -> bool:
    # .py is good
    if filename.endswith(".py"):
        return True

    # if it's not executable, it couldn't be a script
    if not os.access(filename, os.X_OK):
        return False
    # but otherwise, look for a shebang which contains 'python' as a substring
    with open(filename, encoding="utf-8") as fp:
        firstline = fp.readline()
    if firstline.startswith("#!") and "python" in firstline:
        return True

    return False


def all_py_filenames(files, use_git_ls):
    if files:
        yield from files
    elif use_git_ls:
        git_ls_files_proc = subprocess.run(
            ["git", "ls-files"], check=True, capture_output=True, text=True
        )
        candidates = git_ls_files_proc.stdout.split("\n")
        for file in candidates:
            if is_python(file):
                yield file
    else:
        yield from glob.glob("**/*.py", recursive=True)


class AdjacentStringCollector(libcst.CSTVisitor):
    METADATA_DEPENDENCIES = (libcst.metadata.PositionProvider,)

    def __init__(self):
        self.bad_linenos: set[int] = set()

    def visit_ConcatenatedString(self, node: libcst.ConcatenatedString) -> None:
        if libcst.matchers.matches(
            node.whitespace_between, libcst.matchers.SimpleWhitespace()
        ):
            if "\n" not in node.whitespace_between.value:
                lpos = self.get_metadata(
                    libcst.metadata.PositionProvider, node.left
                ).start
                self.bad_linenos.add(lpos.line)


def check_file(filename) -> bool:
    print(f"checking {filename}")
    visitor = AdjacentStringCollector()
    with open(filename) as fp:
        tree = libcst.parse_module(fp.read())
    wrapper = libcst.MetadataWrapper(tree)
    wrapper.visit(visitor)
    bad_lines = sorted(visitor.bad_linenos)
    if bad_lines:
        for lineno in bad_lines:
            print(f"{filename}:{lineno}: unnecessary string concat")
        return False
    return True


def main():
    parser = argparse.ArgumentParser(
        description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument(
        "--use-git-ls", action="store_true", help="find python files from git-ls-files"
    )
    parser.add_argument("files", nargs="*", help="default: all python files")
    args = parser.parse_args()
    if args.use_git_ls and args.files:
        parser.error("--use-git-ls requires no filenames as arguments")

    success = True
    for filename in all_py_filenames(args.files, args.use_git_ls):
        success = check_file(filename) and success

    if not success:
        sys.exit(1)
    print("ok")


if __name__ == "__main__":
    main()


# vim ft=python
