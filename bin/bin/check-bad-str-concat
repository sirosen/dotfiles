#!/usr/bin/env pip-run
# Requirements:
#   libcst
"""
check-bad-str-concat checks for two different flavors of string concatenation which are
allowed by the `black` formatter and other linting tools, but are either unnecessary or
potentially confusing.

E100: unnecessary string concat
    x = "foo " "bar"

E101: unparenthesized multiline string concat in keyword arg
    foo(
        bar="alpha "
        "beta"
    )

E102: unparenthesized multiline string concat in dict value
    {
        "foo": "alpha "
        "beta"
    }
"""
import argparse
import glob
import os
import subprocess
import sys

import libcst
import libcst.matchers

ERROR_MAP = {
    "E100": "unnecessary string concat",
    "E101": "unparenthesized multiline string concat in keyword arg",
    "E102": "unparenthesized multiline string concat in dict value",
}


def is_python(filename: str) -> bool:
    # .py is good
    if filename.endswith(".py"):
        return True

    # if it's not executable, it couldn't be a script
    if not os.access(filename, os.X_OK):
        return False
    # but otherwise, look for a shebang which contains 'python' as a substring
    with open(filename, encoding="utf-8") as fp:
        firstline = fp.readline()
    if firstline.startswith("#!") and "python" in firstline:
        return True

    return False


def all_py_filenames(files, use_git_ls):
    if files:
        yield from files
    elif use_git_ls:
        git_ls_files_proc = subprocess.run(
            ["git", "ls-files"], check=True, capture_output=True, text=True
        )
        candidates = git_ls_files_proc.stdout.split("\n")
        for file in candidates:
            if is_python(file):
                yield file
    else:
        yield from glob.glob("**/*.py", recursive=True)


class ErrorCollector(libcst.CSTVisitor):
    METADATA_DEPENDENCIES = (libcst.metadata.PositionProvider,)

    def __init__(self):
        self.errors: set[tuple[int, str]] = set()

    def visit_ConcatenatedString(self, node: libcst.ConcatenatedString) -> None:
        # check for 'unnecessary string concat' situations
        # e.g.
        #   x = "foo " "bar"
        #
        # these are easily introduced when strings change in length and `black` is run
        # also common when `black` runs for the first time on a project
        if libcst.matchers.matches(
            node.whitespace_between, libcst.matchers.SimpleWhitespace()
        ):
            if "\n" not in node.whitespace_between.value:
                lpos = self.get_metadata(
                    libcst.metadata.PositionProvider, node.left
                ).start
                self.errors.add((lpos.line, "E100"))

    def visit_Call(self, node: libcst.Call) -> None:
        # check for 'unparenthesized multiline string concat in keyword arg'
        # inside of function call sites
        #
        # the scenario here is that the string concat happens across multiple
        # lines, but without parenthesization
        # with a keyword argument getting the value, this is valid but results
        # in a string with different physical indentation levels in the file
        # e.g.
        #   foo(
        #       bar="alpha "
        #       "beta"
        #   )
        #
        # a classic case where this arises naturally is `help=...` for
        # argparse and click, where the help string is often slightly too long
        # for a single line, and easy to "break in two" without adding parens to
        # force the whole block to indent
        for arg in node.args:
            if not arg.keyword:
                continue

            value = arg.value
            if not isinstance(value, libcst.ConcatenatedString):
                continue
            # A left parenthesis exists. Therefore, the string is parenthesized.
            if value.lpar:
                continue

            lpos = self.get_metadata(libcst.metadata.PositionProvider, value.left).start
            self.errors.add((lpos.line, "E101"))

    def visit_DictElement(self, node: libcst.DictElement) -> None:
        value = node.value
        if not isinstance(value, libcst.ConcatenatedString):
            return
        # A left parenthesis exists. Therefore, the string is parenthesized.
        if value.lpar:
            return

        lpos = self.get_metadata(libcst.metadata.PositionProvider, value.left).start
        self.errors.add((lpos.line, "E102"))


def check_file(filename) -> bool:
    print(f"checking {filename}")
    visitor = ErrorCollector()
    with open(filename) as fp:
        tree = libcst.parse_module(fp.read())
    wrapper = libcst.MetadataWrapper(tree)
    wrapper.visit(visitor)
    errors = sorted(visitor.errors)
    if errors:
        for lineno, code in errors:
            print(f"{filename}:{lineno}: {ERROR_MAP[code]} ({code})")
        return False
    return True


def main():
    parser = argparse.ArgumentParser(
        description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument(
        "--use-git-ls", action="store_true", help="find python files from git-ls-files"
    )
    parser.add_argument("files", nargs="*", help="default: all python files")
    args = parser.parse_args()
    if args.use_git_ls and args.files:
        parser.error("--use-git-ls requires no filenames as arguments")

    success = True
    for filename in all_py_filenames(args.files, args.use_git_ls):
        success = check_file(filename) and success

    if not success:
        sys.exit(1)
    print("ok")


if __name__ == "__main__":
    main()


# vim: ft=python
